"""
 This module is responsible for outputting multilane boudaries
 output is (x, y, z, lanenum)

"""
import numpy as np
from sklearn import cluster
from scipy.spatial import distance
import random
from scipy.interpolate import UnivariateSpline
import warnings


class MultiLane:

    def __init__(self, filteredLidarFile, interpolationFile,
                 leftLanes, rightLanes):
        """ 
        Args:
        filteredLidarFile: A .npz file generated by MapBuilder. It should have
                 a 'data' and 't' field
        interpolationFile: A .pickle file containing an interpolated 'left' and
                 'right' lane. This is used to find points in adjacent lanes
        leftLanes: The number of left lanes to look for
        rightLanes: The number of right lanes to look for
        """
        self.npz = np.load(filteredLidarFile)
        self.lanes = self.npz['data']
        self.times = self.npz['t']

        self.interp = np.load(interpolationFile)
        self.leftLanes = leftLanes
        self.rightLanes = rightLanes

    def extrapolateLanes(self):
        """ Performs all steps necessary to find points of interest for lanes """
        self.extendLanes()
        self.filterLaneMarkings()
        self.clusterLanes()
        self.sampleLanes()
        # self.interpolateLanes()
        return self.lanes, self.times

    def saveLanes(self, filepath):
        """ Writes the current state of the generator to a file """
        np.savez(filepath, data=self.lanes, t=self.times)

    def clusterLanes(self):
        """Clusters lanes. A cluster is a sphere of at least 10 points within 3
        meters of eachother. cl.fit_predict may take a long time"""
        cl = cluster.DBSCAN(eps=3, min_samples=10)
        labels = cl.fit_predict(self.lanes[:, :3])
        # Only include points that are in a cluster
        mask = labels > -1
        lanes = np.column_stack((self.lanes[mask, :], labels[mask]))
        times = self.times[mask]
        self.lanes = lanes
        self.times = times
        return self.lanes, self.times

    def extendLanes(self):
        """Translates one interpolated lane to lie on other lanes"""
        left = self.interp['left']
        right = self.interp['right']
        lanes = None
        for imod in xrange(self.rightLanes + self.leftLanes):
            i = imod - self.leftLanes
            lanenew = (right - left) * i + right
            if lanes is not None:
                lanes = np.dstack((lanes, lanenew))
            else:
                lanes = lanenew
        self.interp = lanes
        return self.interp

    def filterLaneMarkings(self):
        """Filters markings close to translated interpolated lane points"""
        lastIndex = 0
        numsegs = 200
        multilanedists = np.ones(
            (self.interp.shape[2], self.lanes.shape[0])) * 1000000
        # find the current index somehow
        for segment in xrange(numsegs):
            if segment % (numsegs / 10) == 0:
                print "Segment ", segment, "/", numsegs
            i = int(float(segment) / numsegs * self.interp.shape[0])
            j = int(float(segment + 1) / numsegs * self.interp.shape[0])
            interpSeg = self.interp[i : j, :,:]
            lastInterpSegPoint = np.array([interpSeg[-1, :, 0]]);
            currentIndex = lastIndex + np.argmin(
                distance.cdist(lastInterpSegPoint, self.lanes[lastIndex:, :3]))
            laneSeg = self.lanes[lastIndex : currentIndex, :];
            for i in xrange(self.interp.shape[2]):
                single = interpSeg[:, :, i]
                singlelanedists = np.min(
                    distance.cdist(laneSeg[:, :3], single[:, :3]), axis=1)
                multilanedists[i, lastIndex:currentIndex] = singlelanedists
            lastIndex = currentIndex
        mins = np.min(multilanedists, axis=0)
        argmins = np.argmin(multilanedists, axis=0)
        # TODO: Why is this hardcoded?
        mask = ((argmins == 0) & (mins < 0.2)) | \
               ((argmins == 1) & (mins < 1.2)) | \
               ((argmins == 2) & (mins < 2.2)) | \
               ((argmins == 3) & (mins < 3.2)) | \
               ((argmins == 4) & (mins < 4.2))
        # mask = ((argmins == 0) & (mins < 0.20)) | \
        #        ((argmins == 1) & (mins < 0.8)) | \
        #        ((argmins == 2) & (mins < 1.2)) | \
        #        ((argmins == 3) & (mins < 2)) | \
        #        ((argmins == 4) & (mins < 2.5))
        filtered = self.lanes[mask]
        filteredargmins = argmins[mask]
        filtered = np.column_stack((filtered, filteredargmins))
        self.lanes = filtered
        self.times = self.times[mask]
        return self.lanes, self.times

    def interpolateLanes(self):
        """Interpolates lane POIs with a univariate spline. This does not work
        as well as expected. TODO: see if a piecewise-linear fit works better"""
        interp_l = np.array([])
        interp_t = np.array([])
        for i in xrange(self.leftLanes + self.rightLanes):
            mask = self.lanes[:, -2] == i
            lane = self.lanes[mask, :]
            times = self.times[mask]

            # Sort the lane with time information
            # sort_order = np.linalg.norm(lane[:, :3], axis=1).argsort()
            sort_order = times.argsort(axis=0)
            sorted_times = times[sort_order]
            sorted_lane = lane[sort_order]

            xinter = UnivariateSpline(sorted_times, sorted_lane[:, 0], s=0)
            yinter = UnivariateSpline(sorted_times, sorted_lane[:, 1], s=0)
            zinter = UnivariateSpline(sorted_times, sorted_lane[:, 2], s=0)
            # 10 points per second
            t = np.arange(sorted_times[0], sorted_times[-1], 10000)
            a = np.column_stack((xinter(t), yinter(t), zinter(t),
                                 np.ones(t.shape[0]) * i))
            if interp_l.shape[0] == 0:
                interp_l = a
                interp_t = t
            else:
                interp_l = np.vstack((interp_l, a))
                interp_t = np.hstack((interp_t, t))
        self.lanes = interp_l
        self.times = interp_t
        return self.lanes, self.times

    def sampleLanes(self):
        """ Chooses the median in a cluster """
        l_centroids = []
        t_centroids = []
        for i in np.unique(self.lanes[:, -1]):
            mask = self.lanes[:, -1] == i
            l_cluster = self.lanes[mask]
            t_cluster = self.times[mask]
            l_sample = np.median(l_cluster, axis=0)
            t_sample = np.median(t_cluster, axis=0)
            l_centroids.append(l_sample)
            t_centroids.append(t_sample)
        self.lanes = np.array(l_centroids)
        self.times = np.array(t_centroids)
        return self.lanes, self.times

if __name__ == '__main__':
    warnings.filterwarnings("ignore")  # filtering warnings
    multiLane = MultiLane('/Users/Phoenix/pranav/files/multilanefiles/lanesraw2.npz',
                          '/Users/Phoenix/pranav/files/singlelanefiles/interpolated.pickle',
                          1, 2)
    multiLane.extrapolateLanes()
    multiLane.saveLanes(
        '/Users/Phoenix/pranav/files/multilanefiles/lanesInterpolated3.npy')
